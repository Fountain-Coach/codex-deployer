# üìÑ CoreDNS Fallback Proposal for FountainAI

**Version:** 1.0  
**Date:** August 3, 2025  
**Author:** Contexter  
**Scope:** Self-hosted fallback for Hetzner DNS, OpenAPI-controlled  

---

## 1. Executive Summary

This document proposes a fully self-hosted fallback for Hetzner DNS using **CoreDNS** as the DNS engine, wrapped in a custom-built, OpenAPI-defined HTTP API. This setup ensures **100% service continuity**, even if Hetzner DNS becomes unavailable or if offline development and testing are required.

The solution is:
- **Cloud-independent**
- **Fully OpenAPI-defined**
- **Compatible with FountainAI's `clientgen` infrastructure**
- GitOps-ready with local or version-controlled zone storage
- Deployable on any Linux/macOS node, including Hetzner VPS

---

## 2. Architecture Overview

### 2.1 Components

| Component        | Description |
|------------------|-------------|
| **CoreDNS**      | Modular DNS server; serves zone files |
| **Zone Store**   | YAML or `.zone` files on disk; version-controlled |
| **DNS API Layer**| Custom HTTP server (FastAPI or SwiftNIO) exposing OpenAPI |
| **FountainAI Clientgen** | Swift 6 client for orchestration and agent control |

### 2.2 Flow Diagram

```
FountainAI/Codex
     ‚Üì
[ClientGen-Swift Client]
     ‚Üì (OpenAPI)
[DNS API Layer]
     ‚Üì (file I/O, reload)
[Zone Files on Disk]
     ‚Üì (watched by)
[CoreDNS]
     ‚Üì
DNS Queries (authoritative)
```

---

## 3. Functional Goals

| Feature | Spec |
|--------|------|
| Zone Management | Create, list, delete zones |
| Record Management | Add, update, delete A/AAAA/CNAME/MX/TXT/etc. |
| Reload Trigger | Trigger CoreDNS to reload changed zones |
| Git Integration | Store zones in Git repo for declarative control |
| OpenAPI Spec | 100% coverage of exposed capabilities |

---

## 4. Justification for CoreDNS

| Capability                     | Evaluation |
|-------------------------------|------------|
| Open-source and production-ready | ‚úÖ |
| Lightweight and embeddable     | ‚úÖ |
| Plugin architecture for logging/reload | ‚úÖ |
| Can serve `.zone` files natively | ‚úÖ |
| Built-in HTTP API              | ‚ùå (but wrapper possible) |
| OpenAPI Control Possible       | ‚úÖ (via wrapper) |
| DNSSEC Support                 | ‚úÖ (via plugins or pre-signing) |

---

## 5. OpenAPI Interface Design

### 5.1 Overview

The API will be defined in **OpenAPI 3.1**, allowing Codex to:
- Generate Swift clients
- Use operation IDs for planning
- Integrate directly with the FountainAI orchestration model

All endpoints are prefixed under `/v1/`.

---

## 6. OpenAPI Path Concepts

```yaml
openapi: 3.1.0
info:
  title: CoreDNS Control API
  version: 1.0.0
paths:
  /v1/zones:
    get:
      summary: List all hosted zones
      operationId: listZones
      responses:
        '200':
          description: A list of all zones
          content:
            application/json:
              schema:
                type: array
                items: { $ref: '#/components/schemas/Zone' }

    post:
      summary: Create a new zone
      operationId: createZone
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/Zone' }
      responses:
        '201':
          description: Zone created

  /v1/zones/{zoneName}/records:
    get:
      summary: List records in a zone
      operationId: getZoneRecords
      parameters:
        - name: zoneName
          in: path
          required: true
          schema: { type: string }
      responses:
        '200':
          description: List of DNS records

    post:
      summary: Add or update a DNS record
      operationId: upsertRecord
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/DNSRecord' }
      responses:
        '200':
          description: Record upserted

    delete:
      summary: Remove a DNS record
      operationId: deleteRecord
      parameters:
        - name: recordId
          in: query
          required: true
          schema: { type: string }
      responses:
        '204':
          description: Record deleted

  /v1/zones/{zoneName}/reload:
    post:
      summary: Trigger a reload of CoreDNS for this zone
      operationId: reloadZone
      responses:
        '202':
          description: Reload triggered

components:
  schemas:
    Zone:
      type: object
      required: [ name ]
      properties:
        name: { type: string }
        records:
          type: array
          items: { $ref: '#/components/schemas/DNSRecord' }

    DNSRecord:
      type: object
      required: [ type, name, value ]
      properties:
        type: { type: string, enum: [A, AAAA, CNAME, TXT, MX, NS] }
        name: { type: string }
        value: { type: string }
        ttl: { type: integer, default: 3600 }
```

---

## 7. Implementation Recommendations

| Component           | Tech |
|---------------------|------|
| API Layer           | SwiftNIO or FastAPI |
| Zone Store          | `.zone` files under `/data/zones/` |
| Reload Mechanism    | `SIGHUP` or CoreDNS reload plugin |
| Validation          | JSONSchema (via OpenAPI spec) |
| Client Generator    | FountainAI `clientgen` (Swift 6) |

---

## 8. Deployment

- The fallback DNS server runs alongside CoreDNS on any node.
- Codex monitors and writes `.swift`-defined zones to Git.
- API reads Git or YAML source and renders `.zone` files.
- CoreDNS picks them up and reloads when changed.

---

## 9. Future Enhancements

- Add full DNSSEC key management
- Add metrics and logging via CoreDNS plugins
- Support `.internal` domains for private orchestration
- Support TXT records for Let's Encrypt DNS challenge automation

---

## 10. Conclusion

This fallback provides full autonomy, avoids cloud vendor lock-in, and fits seamlessly into the FountainAI ecosystem. With an OpenAPI-first approach, it enables programmatic DNS control through Codex agents and GitOps workflows, while using proven, lightweight infrastructure underneath.

---

**Next Step:** Implement OpenAPI interface and client, then integrate with the current planner layer for DNS automation.